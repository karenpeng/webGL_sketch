<script src=lib1.js></script>

<canvas id='canvas1' width='640' height='640'></canvas>

<script id='my_vertex_shader' type='x-shader/x-vertex'>
   attribute vec3 aPosition;
   varying   vec3 vPosition;
   void main() {
      gl_Position = vec4(aPosition, 1.0);
      vPosition = aPosition;
   }
</script>

<script id='my_fragment_shader' type='x-shader/x-fragment'>



   precision mediump float;
   uniform float uTime;
   uniform vec3  uCursor;
   varying vec3  vPosition;
   void main() {
      vec3 color = vec3(0., 0., 0.);                    // Set background color black.
      float x = vPosition.x;                            // Use only x and y coords of
      float y = vPosition.y;                            //   the square's geometry.
     //  float rr = (x * x + y * y) / pow(.5, 2.);         // Compute radius squared.

     //  if (rr < 1.) {                                    // If pixel is on sphere:
     //     float z = sqrt(1. - rr);                       //    compute z.
     //     float t = .2 + .5 * max(0., x + y + z);        //    do shading.
     //     float zSlice = 1. - 3.3 * x + .5 * sin(uTime); //    check for slice.
     //     if (zSlice < z) {                              //    If pixel is on slice:
     //        z = zSlice;                                 //       adjust z,
       // t = z * z < 1. - rr ? .6 : 0.;              //       check for off shape,
     //     }                                              //       do flat shading.
     //     color = vec3(t, t, t);                         //    Make cool easter egg-like
     //     color.r *= 1. + .2 * sin(30. * (x + .5 * z + .03 * sin(20. * y))); // pattern.
     //  }
   float littleX = 0.002;
   float littleY = 0.002;

   for(int i = 0; i < 4; i++){

      littleX += cos(uTime) * .2 + .2;
      littleY -= sin(uTime) * .2;
      float rr1 = ((x - littleX) * (x - littleX) + (y - littleY) * (y - littleY)) / .05;

      if(rr1 < 1.){
         float z = sqrt(1. - rr1);
         float t = .2 + .5 * max(0., x + y + z);
         color = vec3(t - sin(x * 4.) -1., t - sin(y * uTime * 0.03) -1., t - sin(uTime * 4.) -1.);
      }
   }


   float xOff = 0.;
   float yOff = 0.;

   for(float i = 0.; i < 6.; i++){

      xOff = cos(i + uTime) * .5 ;
      yOff = sin(i + uTime) * .5;
      float rr1 = ((x - xOff) * (x - xOff) + (y - yOff) * (y - yOff)) / .06;

      if(rr1 < 1.){
         float z = sqrt(1. - rr1);
         float t = .2 + .5 * max(0., z);
         color = vec3(z, cos(x)*0.01 + sin(uTime * 40.)*0.4, sin(y));
         color.r *= 1. + .2 * sin(30. * (x + .5 * z + .03 * sin(20. * y)));
      }
   }

   x += sin(uTime) * .2;
   y += cos(uTime) * .2;

   float littleColor = 0.;

   for(int i = 0; i < 4; i++){

         littleX += sin(uTime) * .2 + .2;
         littleY -= cos(uTime) * .2;
         float rr1 = ((x - littleX) * (x - littleX) + (y - littleY) * (y - littleY)) / .05;

         littleColor += 0.1 * sin(uTime);

         if(rr1 < 1.){
            float z = sqrt(1. - rr1);
            float t = .2 + .5 * max(0., z);
            color = vec3(t+sin(x), t+littleColor, t);
      }

   }

   gl_FragColor = vec4(color, 1.);
    //gl_FragColor = vec4(x, y , 0., 1.);

   }



</script>

<script>
start_gl('canvas1', document.getElementById('my_vertex_shader'  ).innerHTML,
                    document.getElementById('my_fragment_shader').innerHTML);
</script>

