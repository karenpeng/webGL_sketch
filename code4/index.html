<script src=gl_lib3.js></script>

<script>

// USEFUL MATH: NORMALIZE THE LENGTH OF A 3D VECTOR.

function normalize(v) {
   var s = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
   v[0] /= s;
   v[1] /= s;
   v[2] /= s;
   return v;
}

// INFO ABOUT SHADING THE SURFACE. NOTE THAT SPECULAR REMAINS UNIMPLEMENTED.

var ambient = [0.1, 0.1, 0];
var diffuse = [0.9, 0.9, 0];

// DIRECTION AND COLOR FOR EACH LIGHT SOURCE.

var lightDir = [[1, 0, 0], [-1,1,-1]];
var lightRGB = [[1, 1, 1], [.8,.0,.0]];

// MAKE SURE ALL LIGHT DIRECTIONS ARE UNIT LENGTH.

for (var n = 0 ; n < lightDir.length; n++)
   lightDir[n] = normalize(lightDir[n]);

// INITIALIZE MY UNIFORM SHADER VARIABLES.

var initialize_gl = function(gl) {
   gl.u_ambient = gl.getUniformLocation(gl.prog, "u_ambient");
   gl.u_diffuse = gl.getUniformLocation(gl.prog, "u_diffuse");
   gl.u_lightDir = gl.getUniformLocation(gl.prog, "u_lightDir");
   gl.u_lightRGB = gl.getUniformLocation(gl.prog, "u_lightRGB");
};

// AT EACH ANIMATION FRAME, UPDATE THE VALUES OF MY UNIFORM SHADER VARIABLES.

var update_gl = function(gl) {
   gl.uniform3f(gl.u_ambient, ambient[0], ambient[1], ambient[2]);
   gl.uniform3f(gl.u_diffuse, diffuse[0], diffuse[1], diffuse[2]);

   var L = [];
   for (var n = 0 ; n < lightDir.length ; n++)
      L = L.concat(lightDir[n]);

   gl.uniform3fv(gl.u_lightDir, new Float32Array(L));

   var L = [];
   for (var n = 0 ; n < lightRGB.length ; n++)
      L = L.concat(lightRGB[n]);

   gl.uniform3fv(gl.u_lightRGB, new Float32Array(L));
}

// THE VERTEX SHADER RUNS ONCE PER TRIANGLE VERTEX.

var vertexShader = [
,'   attribute vec3 a_pos;'
,'   varying   vec3 v_pos;'
,'   void main() {'
,'      gl_Position = vec4(a_pos, 1.0);'
,'      v_pos = a_pos;'
,'   }'
].join('\n');

// THE FRAGMENT SHADER RUNS ONCE PER PIXEL FRAGMENT.

/*
   In this case, I am using it to create a make-believe sphere.
   This is so I can show you how to do surface shading, given
   surface properties and lighting info passed in from Javascript.

   I am only implementing ambient and diffuse here.  You will
   need to implement specular as well in your ray tracer,
   which means that you will need to compute the reflection
   direction R.  How to do that is described in the course notes.
*/

var fragmentShader = [
,'   precision mediump float;'
,'   uniform float u_pixelSize;'
,'   uniform float u_time;'
,'   uniform vec3  u_ambient;'
,'   uniform vec3  u_diffuse;'
,'   uniform vec3  u_lightDir[2];'
,'   uniform vec3  u_lightRGB[2];'
,'   uniform vec3  u_mouse;'
,'   varying vec3  v_pos;'
,'   void main() {'

// BACKGROUND PIXELS ARE JUST BLACK.

,'      vec3 color = vec3(0.,0.,0.);'

// SCALE x AND y BY 2, SO THE MAKE-BELIEVE SPHERE TAKES UP ONLY HALF THE IMAGE.

,'      float x = 2.*v_pos.x;'
,'      float y = 2.*v_pos.y;'
,'      float rr = x*x + y*y;'

// DO SHADING CALCULATION ONLY FOR FRAGMENTS THAT ARE INSIDE THE SPHERE'S VISIBLE DISK.

,'      if (rr < 1.) {'
,'         color = u_ambient;'
,'         float z = sqrt(1. - rr);'
,'         vec3 normal = vec3(x, y, z);'
,'         vec3 diffuse = max(0., dot(normal, u_lightDir[0])) * u_lightRGB[0] +'
,'                        max(0., dot(normal, u_lightDir[1])) * u_lightRGB[1] ;'
,'         color += u_diffuse * diffuse;'
,'      }'

// DO GAMMA CORRECTION.

,'      gl_FragColor = vec4(pow(color, vec4(.45, .45,.45,.45)), 1.0);'
,'   }'
].join('\n');

// START GL PROGRAM

start_gl("canvas1", vertexShader, fragmentShader);

</script>

<body bgcolor=black>
<center>
<table>
<tr>
<th>
<font color=white face=helvetica>
Create the image of a shaded sphere in a fragment shader, using a partial implementation of the Phong algorithm.
<p>
<canvas id="canvas1" width="640" height="640"></canvas>
</th>
<td width=50></td>
<td valign=top>
<font color=white face=helvetica>
In this variant of the code, I show a partial implementation of the Phong reflectance algorithm.
Specular reflection remains unimplemented.
</td>
</tr>
</table>
</center>

